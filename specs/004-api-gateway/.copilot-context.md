# Copilot Context: API Gateway (004-api-gateway)

> **Feature-Specific Agent Context** - 此檔案僅在 `004-api-gateway` 分支開發期間使用，避免與其他並行開發的 feature 分支產生合併衝突。合併到 master 後，內容將由 `.specify/scripts/bash/merge-agent-contexts.sh` 整合到全域的 `.github/copilot-instructions.md`。

---

## Active Technologies

### Core Stack
- **Language**: C# 12
- **Framework**: ASP.NET Core 10 (.NET 10.0)
- **Architecture**: Web API (Controller-based, 單一專案)

### Primary Dependencies
- **YARP** (Yarp.ReverseProxy 2.1.0) - 反向代理與路由引擎
- **JWT Authentication** (Microsoft.AspNetCore.Authentication.JwtBearer) - JWT HS256 驗證
- **Redis** (StackExchange.Redis 2.8+) - Rate Limiting 計數器與分散式快取
- **Polly** (Polly 8.0+) - HTTP 重試與彈性策略
- **Serilog** (Serilog.AspNetCore) - 結構化日誌
- **System.Text.Json** - JSON 序列化（不使用 Newtonsoft.Json）

### Testing Stack
- **xUnit** - 單元測試框架
- **Moq** - Mocking 框架
- **FluentAssertions** - 流暢斷言 API
- **WebApplicationFactory** - ASP.NET Core 整合測試
- **Testcontainers** (Testcontainers.Redis) - Redis 容器化測試環境
- **BenchmarkDotNet** - 效能基準測試（用於驗證路由延遲 < 10ms 目標）

### Infrastructure
- **Redis** - Rate Limiting 計數器（多實例共享狀態）
- **Docker** - Linux 容器部署（multi-stage build）
- **Target Platform**: Linux x64 容器，Kubernetes 就緒

---

## Project Structure

```
src/
└── ApiGateway/                    # 單一專案（Gateway 本身不拆分為多專案）
    ├── ApiGateway.csproj
    ├── Program.cs                 # 應用程式進入點
    ├── appsettings.json           # 後端服務靜態路由設定
    ├── appsettings.Development.json
    ├── Controllers/
    │   └── AggregationController.cs  # 請求聚合端點（/api/aggregation/*）
    ├── Middlewares/
    │   ├── ErrorHandlingMiddleware.cs     # 統一錯誤處理
    │   ├── RateLimitingMiddleware.cs      # Rate Limiting 檢查
    │   └── CorrelationIdMiddleware.cs     # 注入 X-Gateway-Request-Id
    ├── Services/
    │   ├── RateLimitService.cs            # Redis 計數邏輯
    │   ├── ServiceDiscovery/
    │   │   ├── IServiceDiscovery.cs       # 服務發現抽象（未來遷移 Consul）
    │   │   └── StaticServiceDiscovery.cs  # appsettings.json 靜態設定實作
    │   └── HttpClients/
    │       ├── IMemberServiceClient.cs    # Member Service HTTP 客戶端介面
    │       ├── MemberServiceClient.cs
    │       ├── IAuctionServiceClient.cs
    │       └── AuctionServiceClient.cs
    ├── Models/
    │   ├── ErrorResponse.cs               # 統一錯誤格式
    │   └── AggregationModels/
    │       ├── AuctionWithBidsResponse.cs # /api/aggregation/auctions/{id} DTO
    │       └── UserAuctionsResponse.cs    # /api/aggregation/users/{id}/auctions DTO
    └── HealthChecks/
        └── BackendServiceHealthCheck.cs   # 後端服務健康檢查邏輯

tests/
└── ApiGateway.Tests/
    ├── ApiGateway.Tests.csproj
    ├── Unit/
    │   ├── RateLimitServiceTests.cs       # 單元測試: Rate Limiting 邏輯
    │   ├── ErrorHandlingMiddlewareTests.cs
    │   └── ServiceDiscoveryTests.cs
    ├── Integration/
    │   ├── RoutingTests.cs                # 整合測試: YARP 路由規則
    │   ├── JwtAuthenticationTests.cs      # 整合測試: JWT 驗證流程
    │   ├── RateLimitingTests.cs           # 整合測試: Redis Rate Limiting（使用 Testcontainers）
    │   ├── AggregationTests.cs            # 整合測試: 請求聚合端點
    │   └── ErrorHandlingTests.cs          # 整合測試: 統一錯誤回應
    └── Performance/
        └── RoutingBenchmarks.cs           # BenchmarkDotNet: 驗證路由延遲 < 10ms

specs/004-api-gateway/
├── spec.md                                # Feature 規格文件
├── plan.md                                # 實作計畫
├── tasks.md                               # 189 個實作任務
├── data-model.md                          # 資料模型（DTO 定義）
├── analyze-004.md                         # 規格分析報告（Quality 98/100）
└── contracts/
    ├── routes.yaml                        # YARP 路由規則定義
    ├── aggregation-endpoints.yaml         # 請求聚合端點契約
    └── error-responses.json               # 統一錯誤格式範例

Dockerfile                                 # Multi-stage build（.NET 10 SDK + Runtime）
.dockerignore
```

---

## Constitution Principles (From `.specify/constitution/constitution.md`)

### I. Code Quality First ✅
- YARP 提供清晰的路由抽象，避免手寫複雜路由邏輯
- JWT 驗證透過 ASP.NET Core Authentication Middleware，符合依賴注入原則
- 業務邏輯（請求聚合、錯誤處理）與基礎設施（YARP、Redis）分離
- Rate Limiting 邏輯封裝為 `RateLimitService`，可注入與單元測試

### II. Test-Driven Development (NON-NEGOTIABLE) ✅
- **單元測試覆蓋率目標**: > 80%
- **測試分層**:
  - 單元測試: 服務邏輯（RateLimitService, ServiceDiscovery）
  - 整合測試: API 端點（路由、JWT、Rate Limiting、聚合）
  - 效能測試: BenchmarkDotNet 驗證延遲目標
- **TDD 工作流**: 所有 User Story 實作遵循「先寫測試，後寫實作」順序
- 使用 Testcontainers.Redis 提供隔離的 Redis 測試環境

### III. User Experience Consistency ✅
- **統一錯誤格式** (FR-004):
  ```json
  {
    "code": "AUTH_TOKEN_EXPIRED",
    "message": "Token expired",
    "details": { "expiredAt": "2025-11-05T10:00:00Z" },
    "timestamp": "2025-11-05T10:05:00Z",
    "path": "/api/members/profile"
  }
  ```
- **HTTP 狀態碼標準**:
  - `401` 未授權（Token 無效/過期/缺失）
  - `429` Rate Limit 超過（包含 `Retry-After` 標頭）
  - `503` 後端服務不可用
  - `504` 後端服務超時（30 秒）
- **驗證訊息清楚**: "Token expired", "Invalid token", "Malformed token"

### IV. Performance Requirements ✅
- **效能目標**:
  - 路由延遲 < 10ms (P95)
  - JWT 驗證延遲 < 20ms (P95)
  - 請求聚合回應時間 < 300ms (P95，並行呼叫後端服務)
  - 系統可用性 > 99.9%
- **最佳化策略**:
  - 請求聚合使用 `Task.WhenAll` 並行呼叫後端服務
  - Redis 使用連線池避免連線開銷
  - 所有 I/O 操作非同步處理（HttpClient, Redis）
  - 共用 30 秒超時使用 `CancellationTokenSource`（非累加）

### V. Observability and Monitoring ✅
- **結構化日誌** (Serilog):
  - 記錄所有請求: 路徑、方法、狀態碼、延遲、使用者 ID、IP
  - Correlation ID (`X-Gateway-Request-Id`) 追蹤請求
- **APM 指標** (FR-012):
  - 請求數（每秒）
  - 錯誤率（HTTP 5xx）
  - 延遲分佈（P50/P95/P99）
  - Rate Limit 觸發次數
  - Redis 降級事件次數
- **健康檢查**: `/health` 端點監控後端服務狀態

### VI. Security by Design ✅
- **JWT HS256 驗證**: 對稱金鑰，適合內部微服務
- **Rate Limiting**: 100 requests/minute/IP（Redis 計數器: `ratelimit:{ip}:{minute}`）
- **CORS 設定**: 僅允許白名單來源（可設定）
- **請求大小限制**: 10MB
- **Redis 降級策略**: Redis 不可用時暫時允許請求通過並記錄告警（優先可用性）

---

## Key Design Decisions

### 1. 後端服務發現: 靜態設定檔 + 抽象介面（未來遷移 Consul）
**決策**: 使用 `appsettings.json` 靜態設定後端服務 URL，但透過 `IServiceDiscovery` 抽象介面訪問。

**理由**:
- 初期部署簡化（無需額外 Consul 基礎設施）
- 未來可無痛遷移到 Consul（僅需實作 `ConsulServiceDiscovery`）
- 測試時可注入 Mock 實作

**範例**:
```json
// appsettings.json
{
  "BackendServices": {
    "MemberService": "http://member-service:8001",
    "AuctionService": "http://auction-service:8002",
    "BiddingService": "http://bidding-service:8003"
  }
}
```

### 2. 請求聚合: 並行呼叫 + 共用超時
**決策**: 使用 `Task.WhenAll` 並行呼叫後端服務，所有呼叫共用單一 30 秒超時（使用 `CancellationTokenSource`）。

**理由**:
- 並行執行減少總延遲（總延遲 = 最慢的服務，而非累加）
- 共用超時避免總超時時間 = 服務數量 × 30 秒
- 符合 FR-010 超時要求與 spec.md 澄清事項

**範例**:
```csharp
using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30));
var tasks = new[] {
    _memberClient.GetUserAsync(userId, cts.Token),
    _auctionClient.GetAuctionsAsync(userId, cts.Token),
    _biddingClient.GetBidsAsync(userId, cts.Token)
};
await Task.WhenAll(tasks);
```

### 3. 重試策略: 僅 GET 請求重試
**決策**: POST/PUT/DELETE 請求**永不重試**，僅 GET 請求允許重試（Polly: 最多 3 次，指數退避）。

**理由**:
- 避免重複交易（例如重複出價、重複建立拍賣）
- GET 請求冪等性，可安全重試
- 符合 FR-014 重試機制要求

### 4. Rate Limiting: Redis 計數器 + 降級策略
**決策**: 使用 Redis 儲存 Rate Limit 計數器（鍵格式: `ratelimit:{ip}:{minute}`），Redis 不可用時暫時允許請求通過並記錄告警。

**理由**:
- Redis 支援多實例共享狀態（水平擴展）
- 降級策略優先可用性（短期犧牲限流功能）
- 符合 FR-006 Rate Limiting 規則

---

## Common Commands

### Development
```powershell
# 啟動 API Gateway（開發模式）
cd src/ApiGateway
dotnet run --environment Development

# 執行所有測試
cd tests/ApiGateway.Tests
dotnet test

# 執行單元測試（快速驗證）
dotnet test --filter "FullyQualifiedName~Unit"

# 執行整合測試（包含 Testcontainers Redis）
dotnet test --filter "FullyQualifiedName~Integration"

# 執行效能基準測試
cd tests/ApiGateway.Tests/Performance
dotnet run -c Release --framework net10.0
```

### Docker
```powershell
# 建置 Docker 映像
docker build -t auction-api-gateway:latest .

# 執行容器（需要 Redis）
docker run -d --name redis -p 6379:6379 redis:7-alpine
docker run -d --name api-gateway -p 8000:8080 `
  -e ASPNETCORE_ENVIRONMENT=Production `
  -e BackendServices__MemberService=http://host.docker.internal:8001 `
  -e Redis__ConnectionString=host.docker.internal:6379 `
  auction-api-gateway:latest

# 健康檢查
curl http://localhost:8000/health
```

### Testing
```powershell
# 測試路由（需要有效 JWT）
$token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
Invoke-RestMethod -Uri "http://localhost:8000/api/members/profile" `
  -Headers @{ "Authorization" = "Bearer $token" }

# 測試 Rate Limiting（連續發送請求）
1..120 | ForEach-Object {
  Invoke-RestMethod -Uri "http://localhost:8000/api/members/1" `
    -Headers @{ "Authorization" = "Bearer $token" }
}

# 測試請求聚合
Invoke-RestMethod -Uri "http://localhost:8000/api/aggregation/auctions/123" `
  -Headers @{ "Authorization" = "Bearer $token" }
```

---

## Critical Implementation Notes

### ⚠️ JWT 驗證設定（Avoid Common Pitfalls）
```csharp
// ❌ 錯誤: 未驗證 Issuer/Audience
services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options => {
        options.TokenValidationParameters = new TokenValidationParameters {
            IssuerSigningKey = new SymmetricSecurityKey(key),
            ValidateIssuerSigningKey = true,
            ValidateIssuer = false,  // ❌ 不安全
            ValidateAudience = false // ❌ 不安全
        };
    });

// ✅ 正確: 驗證 Issuer/Audience/Lifetime
options.TokenValidationParameters = new TokenValidationParameters {
    ValidateIssuerSigningKey = true,
    IssuerSigningKey = new SymmetricSecurityKey(key),
    ValidateIssuer = true,
    ValidIssuer = "auction-service",
    ValidateAudience = true,
    ValidAudience = "auction-api",
    ValidateLifetime = true,
    ClockSkew = TimeSpan.FromMinutes(5)
};
```

### ⚠️ YARP 路由優先順序（避免衝突）
```json
// ❌ 錯誤: 聚合路由會被通用路由覆蓋
{
  "Routes": {
    "member-route": {
      "ClusterId": "member-service",
      "Match": { "Path": "/api/members/{**catch-all}" }  // ❌ 先匹配
    },
    "aggregation-route": {
      "ClusterId": "api-gateway",
      "Match": { "Path": "/api/aggregation/{**catch-all}" }  // ❌ 永遠不會被匹配
    }
  }
}

// ✅ 正確: 聚合路由優先於通用路由（使用 Order）
"aggregation-route": {
  "ClusterId": "api-gateway",
  "Match": { "Path": "/api/aggregation/{**catch-all}" },
  "Order": 1  // ✅ 優先匹配
},
"member-route": {
  "ClusterId": "member-service",
  "Match": { "Path": "/api/members/{**catch-all}" },
  "Order": 2
}
```

### ⚠️ Redis 連線池（避免連線耗盡）
```csharp
// ❌ 錯誤: 每次請求建立新連線
public class RateLimitService {
    public async Task<bool> CheckLimitAsync(string ip) {
        var redis = ConnectionMultiplexer.Connect("localhost:6379");  // ❌ 連線洩漏
        var db = redis.GetDatabase();
        // ...
    }
}

// ✅ 正確: 使用單例 ConnectionMultiplexer
public class RateLimitService {
    private readonly IConnectionMultiplexer _redis;
    
    public RateLimitService(IConnectionMultiplexer redis) {
        _redis = redis;  // ✅ 注入單例
    }
    
    public async Task<bool> CheckLimitAsync(string ip) {
        var db = _redis.GetDatabase();
        // ...
    }
}

// Startup.cs
services.AddSingleton<IConnectionMultiplexer>(sp => 
    ConnectionMultiplexer.Connect(configuration["Redis:ConnectionString"]));
```

---

## Test Strategy

### Unit Tests (單元測試)
**範圍**: 獨立服務邏輯，無外部依賴  
**工具**: xUnit + Moq + FluentAssertions

**範例**:
```csharp
// RateLimitServiceTests.cs
[Fact]
public async Task CheckLimitAsync_ShouldReturnTrue_WhenUnderLimit() {
    // Arrange
    var redisMock = new Mock<IDatabase>();
    redisMock.Setup(x => x.StringIncrementAsync(It.IsAny<RedisKey>(), 1, CommandFlags.None))
             .ReturnsAsync(50);  // 模擬計數器 = 50
    var service = new RateLimitService(redisMock.Object);

    // Act
    var result = await service.CheckLimitAsync("192.168.1.1");

    // Assert
    result.Should().BeTrue();  // 50 < 100，未超過限制
}
```

### Integration Tests (整合測試)
**範圍**: API 端點 + 實際 Redis（Testcontainers）  
**工具**: WebApplicationFactory + Testcontainers.Redis

**範例**:
```csharp
// RateLimitingTests.cs
public class RateLimitingTests : IClassFixture<WebApplicationFactory<Program>> {
    private readonly RedisContainer _redisContainer = new RedisBuilder()
        .WithImage("redis:7-alpine")
        .Build();

    [Fact]
    public async Task RateLimit_ShouldReturn429_WhenExceeds100Requests() {
        // Arrange
        await _redisContainer.StartAsync();
        var client = _factory.CreateClient();
        
        // Act: 發送 120 個請求
        var tasks = Enumerable.Range(1, 120)
            .Select(_ => client.GetAsync("/api/members/1"));
        var responses = await Task.WhenAll(tasks);

        // Assert: 前 100 個成功，後 20 個返回 429
        responses.Take(100).Should().OnlyContain(r => r.StatusCode == HttpStatusCode.OK);
        responses.Skip(100).Should().OnlyContain(r => r.StatusCode == (HttpStatusCode)429);
    }
}
```

### Performance Tests (效能測試)
**範圍**: 驗證路由延遲 < 10ms 目標  
**工具**: BenchmarkDotNet

**範例**:
```csharp
// RoutingBenchmarks.cs
[MemoryDiagnoser]
public class RoutingBenchmarks {
    private HttpClient _client;

    [GlobalSetup]
    public void Setup() {
        var factory = new WebApplicationFactory<Program>();
        _client = factory.CreateClient();
    }

    [Benchmark]
    public async Task<HttpResponseMessage> RouteToMemberService() {
        return await _client.GetAsync("/api/members/1");
    }
}
```

---

## Implementation Status

**Branch**: `004-api-gateway`  
**Current Phase**: Phase 2 - Analysis & Remediation Complete  
**Quality Score**: 98/100 (Excellent)  
**Blocking Issues**: 0 (All HIGH/MEDIUM resolved)  
**Total Tasks**: 189  

**Next Steps**:
1. Commit specification fixes (`git commit -m "fix: resolve all HIGH and MEDIUM spec issues"`)
2. Begin Phase 1 implementation (Setup: T001-T031)
3. Follow TDD approach: Write tests first for each User Story

---

## Related Documents

- **Feature Specification**: [specs/004-api-gateway/spec.md](./spec.md)
- **Implementation Plan**: [specs/004-api-gateway/plan.md](./plan.md)
- **Task Breakdown**: [specs/004-api-gateway/tasks.md](./tasks.md) (189 tasks)
- **Analysis Report**: [specs/004-api-gateway/analyze-004.md](./analyze-004.md)
- **Data Model**: [specs/004-api-gateway/data-model.md](./data-model.md)
- **API Contracts**:
  - [contracts/routes.yaml](./contracts/routes.yaml)
  - [contracts/aggregation-endpoints.yaml](./contracts/aggregation-endpoints.yaml)
  - [contracts/error-responses.json](./contracts/error-responses.json)

---

## Conflict Resolution Strategy

**合併到 master 前**:
1. 確認本檔案僅存在於 `specs/004-api-gateway/.copilot-context.md`
2. **不要修改** `.github/copilot-instructions.md`（避免合併衝突）
3. 提交時包含完整 `specs/004-api-gateway/` 目錄

**合併到 master 後**:
```powershell
# 切換到 master 分支
git checkout master
git merge 004-api-gateway

# 執行整合腳本（將此檔案內容合併到全域設定）
.specify/scripts/bash/merge-agent-contexts.sh

# 提交更新後的全域檔案
git add .github/copilot-instructions.md
git commit -m "chore: update global agent context after merging 004-api-gateway"
```

---

**最後更新**: 2025-12-04  
**規格版本**: 1.0  
**狀態**: ✅ Ready for Implementation
