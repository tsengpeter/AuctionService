# AuctionService Development Context (003-bidding-service)

**Feature-Specific AI Context** | **Branch**: 003-bidding-service | **Last Updated**: 2025-12-04

## Feature Overview

競標服務後端 REST API，負責處理所有出價相關的邏輯與歷史記錄，確保競標過程的公平性、即時性與一致性。採用 Redis Write-Behind Cache 架構搭配 PostgreSQL 持久化存儲，使用 Lua Script 確保併發安全，背景 Worker 進行非同步批次同步。

**核心特性**:
- 高效能出價處理（< 10ms P95 寫入延遲）
- Redis Write-Behind Cache 架構
- Lua Script 原子操作確保併發安全
- PostgreSQL 欄位層級加密（AES-256-GCM）
- 雪花 ID (Snowflake ID) 統一主鍵生成
- Correlation ID 分散式追蹤
- 背景 Worker 非同步批次同步
- 與 Auction Service 整合（商品資訊驗證）

## Active Technologies

### Core Stack
- **Language**: C# 13 / .NET 10 LTS
- **Framework**: ASP.NET Core 10 Web API (Controller-based, **不使用 Minimal APIs**)
- **Database**: PostgreSQL 16
- **ORM**: Entity Framework Core 10 (Code First workflow)
- **Cache/Write Layer**: Redis 7+ (AOF 持久化)

### Key Dependencies
- **StackExchange.Redis** 2.7+ - Redis 客戶端
- **Npgsql.EntityFrameworkCore.PostgreSQL** 10.0+ - PostgreSQL 驅動
- **IdGen** 3.0+ (或 Snowflake.Core) - 雪花 ID 生成
- **Serilog.AspNetCore** 10.0 - 結構化日誌
- **Polly** 8.0+ - HTTP 重試策略（整合 Auction Service）
- **Azure.Security.KeyVault.Secrets** 4.5+ - 加密金鑰管理
- **FluentValidation.AspNetCore** 11.3.0 - 輸入驗證
- **Swashbuckle.AspNetCore** 6.5+ - OpenAPI 文件生成

### Testing Stack
- **xUnit** 2.6+ - 測試框架
- **Moq** 4.20+ - Mock 框架
- **FluentAssertions** 6.12+ - 斷言庫
- **Testcontainers.PostgreSql** 3.7+ - PostgreSQL 整合測試容器
- **Testcontainers.Redis** 3.7+ - Redis 整合測試容器

### Architecture Pattern
- **Repository Pattern + Service Layer**: 資料存取抽象與業務邏輯分離
- **Write-Behind Cache**: Redis 作為寫入層，背景同步至 PostgreSQL
- **POCO DTOs**: 手動映射，**不使用 AutoMapper**
- **Background Worker**: IHostedService 批次同步

## Project Structure

```text
specs/003-bidding-service/
├── src/
│   └── BiddingService.API/
│       ├── Controllers/               # API 控制器
│       │   ├── BidsController.cs
│       │   └── HealthController.cs
│       ├── Services/                  # 業務邏輯層
│       │   ├── BidService.cs
│       │   ├── RedisCacheService.cs
│       │   └── AuctionServiceClient.cs
│       ├── Repositories/              # 資料存取層
│       │   ├── BidRepository.cs
│       │   └── Interfaces/
│       ├── Infrastructure/            # 基礎設施
│       │   ├── Data/
│       │   │   ├── BiddingDbContext.cs
│       │   │   └── Configurations/
│       │   │       └── BidConfiguration.cs
│       │   ├── Encryption/
│       │   │   ├── EncryptionService.cs
│       │   │   └── EncryptionValueConverter.cs
│       │   ├── IdGeneration/
│       │   │   └── SnowflakeIdGenerator.cs
│       │   └── BackgroundWorkers/
│       │       └── RedisSyncWorker.cs
│       ├── Middleware/                # 中介軟體
│       │   ├── CorrelationIdMiddleware.cs
│       │   └── ExceptionHandlingMiddleware.cs
│       ├── Models/                    # 資料模型
│       │   ├── Entities/
│       │   │   └── Bid.cs
│       │   ├── DTOs/
│       │   │   ├── CreateBidRequest.cs
│       │   │   └── BidResponse.cs
│       │   └── ValueObjects/
│       │       └── BidAmount.cs
│       ├── Scripts/                   # Redis Lua Scripts
│       │   └── place-bid.lua
│       ├── appsettings.json
│       ├── appsettings.Development.json
│       └── Program.cs
└── tests/
    ├── BiddingService.UnitTests/      # 單元測試
    └── BiddingService.IntegrationTests/ # 整合測試 (Testcontainers)

└── loadtests/
    └── BiddingService.LoadTests/       # 負載測試
```

## Commands

### Development

```powershell
# 啟動開發環境
cd specs/003-bidding-service
dotnet restore
dotnet build

# 執行 API
cd src/BiddingService.API
dotnet run

# 啟動 Docker Compose (PostgreSQL + Redis)
cd specs/003-bidding-service
docker-compose up -d

# 驗證容器狀態
docker-compose ps

# EF Core Migrations
dotnet ef migrations add InitialCreate --project src/BiddingService.API
dotnet ef database update --project src/BiddingService.API

# 查看 Redis 資料
docker exec -it redis_bidding redis-cli
> KEYS auction:*
> ZRANGE auction:123456789:bids 0 -1 WITHSCORES
> HGETALL auction:123456789:highest_bid
```

### Testing

```powershell
# 執行所有測試
dotnet test

# 執行單元測試
dotnet test tests/BiddingService.UnitTests

# 執行整合測試 (使用 Testcontainers)
dotnet test tests/BiddingService.IntegrationTests

# 執行負載測試
cd loadtests/BiddingService.LoadTests
dotnet run

# 測試覆蓋率報告
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover
```

### Database

```sql
-- 查詢所有出價記錄
SELECT "BidId", "AuctionId", "Amount", "BidAt", "CreatedAt", "SyncedFromRedis"
FROM "Bids"
ORDER BY "BidAt" DESC
LIMIT 20;

-- 查詢特定商品的出價歷史
SELECT "BidId", "Amount", "BidAt"
FROM "Bids"
WHERE "AuctionId" = 123456789
ORDER BY "BidAt" DESC;

-- 查詢待同步的出價數量
-- (注意: 此查詢在 Redis，非 PostgreSQL)
-- Redis CLI: SCARD pending_bids
```

## Code Style

### Controller Pattern (Controller-based, 不使用 Minimal APIs)

```csharp
[ApiController]
[Route("api/[controller]")]
public class BidsController : ControllerBase
{
    private readonly IBidService _bidService;
    private readonly ILogger<BidsController> _logger;

    public BidsController(IBidService bidService, ILogger<BidsController> logger)
    {
        _bidService = bidService;
        _logger = logger;
    }

    [HttpPost]
    [Authorize]
    [ProducesResponseType(typeof(BidResponse), StatusCodes.Status201Created)]
    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status400BadRequest)]
    [ProducesResponseType(typeof(ErrorResponse), StatusCodes.Status409Conflict)]
    public async Task<IActionResult> CreateBid([FromBody] CreateBidRequest request)
    {
        var correlationId = HttpContext.Items["CorrelationId"]?.ToString();
        var bidderId = GetUserIdFromToken(); // 從 JWT Token 取得

        var result = await _bidService.PlaceBidAsync(request, bidderId, correlationId);

        if (!result.Success)
            return Conflict(new ErrorResponse
            {
                Code = result.ErrorCode,
                Message = result.ErrorMessage,
                CorrelationId = correlationId,
                Timestamp = DateTime.UtcNow
            });

        return CreatedAtAction(
            nameof(GetBidById),
            new { bidId = result.Data.BidId },
            result.Data);
    }

    [HttpGet("auctions/{auctionId}/bids")]
    [ProducesResponseType(typeof(BidListResponse), StatusCodes.Status200OK)]
    public async Task<IActionResult> GetBidsByAuction(
        long auctionId,
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 20)
    {
        var result = await _bidService.GetBidsByAuctionAsync(auctionId, page, pageSize);
        return Ok(result);
    }
}
```

### Redis Lua Script (Atomic Bid Placement)

```lua
-- place-bid.lua
local auction_key = KEYS[1]                     -- auction:{auctionId}:highest_bid
local bids_key = KEYS[2]                        -- auction:{auctionId}:bids
local pending_key = KEYS[3]                     -- pending_bids

local bid_id = ARGV[1]
local bidder_id = ARGV[2]
local amount = tonumber(ARGV[3])
local timestamp = ARGV[4]
local starting_price = tonumber(ARGV[5])
local ttl_seconds = tonumber(ARGV[6])

-- 取得當前最高出價
local current_highest = redis.call('HGET', auction_key, 'amount')

-- 檢查金額
local required_amount = starting_price
if current_highest then
    required_amount = tonumber(current_highest)
end

if amount <= required_amount then
    return {err = 'AMOUNT_TOO_LOW'}
end

-- 原子操作：更新 Sorted Set, Hash, Pending Set
redis.call('ZADD', bids_key, amount, bid_id .. ':' .. timestamp .. ':' .. bidder_id)
redis.call('HMSET', auction_key, 'bidId', bid_id, 'bidderId', bidder_id, 'amount', amount, 'bidAt', timestamp)
redis.call('SADD', pending_key, bid_id)
redis.call('EXPIRE', bids_key, ttl_seconds)
redis.call('EXPIRE', auction_key, ttl_seconds)

return {ok = 'SUCCESS'}
```

### C# Lua Script Execution

```csharp
public class RedisCacheService
{
    private readonly IConnectionMultiplexer _redis;
    private readonly IDatabase _redisDb;
    private readonly LuaScript _placeBidScript;

    public RedisCacheService(IConnectionMultiplexer redis)
    {
        _redis = redis;
        _redisDb = redis.GetDatabase();
        _placeBidScript = LuaScript.Prepare(File.ReadAllText("Scripts/place-bid.lua"));
    }

    public async Task<Result> PlaceBidAsync(
        long auctionId,
        long bidId,
        long bidderId,
        decimal amount,
        decimal startingPrice,
        int ttlSeconds)
    {
        var highestBidKey = $"auction:{auctionId}:highest_bid";
        var bidsKey = $"auction:{auctionId}:bids";
        var pendingKey = "pending_bids";
        var timestamp = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

        var result = await _redisDb.ScriptEvaluateAsync(_placeBidScript,
            keys: new RedisKey[] { highestBidKey, bidsKey, pendingKey },
            values: new RedisValue[] { bidId, bidderId, amount, timestamp, startingPrice, ttlSeconds }
        );

        if (result.IsNull)
            return Result.Fail("REDIS_ERROR", "Redis Script 執行失敗");

        var resultDict = (RedisResult[])result;
        if (resultDict[0].ToString() == "err")
            return Result.Fail(resultDict[1].ToString(), "出價金額必須高於當前最高價");

        return Result.Ok();
    }
}
```

### EF Core Value Converter (Field Encryption)

```csharp
public class EncryptionValueConverter : ValueConverter<string, string>
{
    private readonly IEncryptionService _encryptionService;

    public EncryptionValueConverter(IEncryptionService encryptionService)
        : base(
            v => encryptionService.Encrypt(v),
            v => encryptionService.Decrypt(v))
    {
        _encryptionService = encryptionService;
    }
}

public class BidConfiguration : IEntityTypeConfiguration<Bid>
{
    private readonly IEncryptionService _encryptionService;

    public void Configure(EntityTypeBuilder<Bid> builder)
    {
        builder.ToTable("Bids");

        builder.HasKey(b => b.BidId);

        // Amount: 加密儲存為 TEXT (Base64)
        builder.Property(b => b.Amount)
            .HasConversion(
                v => _encryptionService.Encrypt(v.ToString("F2")),
                v => decimal.Parse(_encryptionService.Decrypt(v)))
            .HasColumnType("text")
            .IsRequired();

        // BidderId: 加密儲存為 TEXT
        builder.Property(b => b.BidderId)
            .HasConversion(
                v => _encryptionService.Encrypt(v.ToString()),
                v => long.Parse(_encryptionService.Decrypt(v)))
            .HasColumnType("text")
            .IsRequired();

        // BidderIdHash: SHA-256 Hash 用於索引查詢
        builder.Property(b => b.BidderIdHash)
            .HasColumnType("char(64)")
            .IsRequired();

        // 索引
        builder.HasIndex(b => new { b.AuctionId, b.BidAt })
            .HasDatabaseName("IX_Bids_AuctionId_BidAt")
            .IsDescending(false, true); // BidAt DESC

        builder.HasIndex(b => b.BidAt)
            .HasDatabaseName("IX_Bids_BidAt")
            .IsDescending(true);

        builder.HasIndex(b => new { b.BidderIdHash, b.BidAt })
            .HasDatabaseName("IX_Bids_BidderIdHash_BidAt")
            .IsDescending(false, true);
    }
}
```

### Background Worker (Redis → PostgreSQL Sync)

```csharp
public class RedisSyncWorker : BackgroundService
{
    private readonly IServiceProvider _serviceProvider;
    private readonly ILogger<RedisSyncWorker> _logger;
    private readonly IConnectionMultiplexer _redis;

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("Redis Sync Worker started");

        while (!stoppingToken.IsCancellationRequested)
        {
            try
            {
                await SyncPendingBidsAsync(stoppingToken);
                await Task.Delay(TimeSpan.FromSeconds(1), stoppingToken);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error in Redis Sync Worker");
            }
        }
    }

    private async Task SyncPendingBidsAsync(CancellationToken cancellationToken)
    {
        var db = _redis.GetDatabase();
        var pendingBidIds = await db.SetPopAsync("pending_bids", 1000);

        if (pendingBidIds.Length == 0)
            return;

        using var scope = _serviceProvider.CreateScope();
        var repository = scope.ServiceProvider.GetRequiredService<IBidRepository>();
        var bids = new List<Bid>();

        foreach (var bidId in pendingBidIds)
        {
            // 從 Redis 取得出價詳細資料
            var bid = await GetBidFromRedisAsync(db, long.Parse(bidId));
            if (bid != null)
                bids.Add(bid);
        }

        if (bids.Any())
        {
            await repository.AddRangeAsync(bids);
            _logger.LogInformation("Synced {Count} bids to PostgreSQL", bids.Count);
        }
    }
}
```

### Correlation ID Middleware

```csharp
public class CorrelationIdMiddleware
{
    private readonly RequestDelegate _next;

    public CorrelationIdMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var correlationId = context.Request.Headers["X-Correlation-Id"].FirstOrDefault()
            ?? Guid.NewGuid().ToString();

        context.Items["CorrelationId"] = correlationId;
        context.Response.Headers.Add("X-Correlation-Id", correlationId);

        using (LogContext.PushProperty("CorrelationId", correlationId))
        {
            await _next(context);
        }
    }
}
```

### POCO DTO Mapping (手動映射，不使用 AutoMapper)

```csharp
public static class BidMappingExtensions
{
    public static BidResponse ToResponse(this Bid bid, bool isHighest = false)
    {
        return new BidResponse
        {
            BidId = bid.BidId,
            AuctionId = bid.AuctionId,
            BidderId = bid.BidderId,
            Amount = bid.Amount,
            BidAt = bid.BidAt,
            IsHighest = isHighest
        };
    }

    public static Bid ToEntity(this CreateBidRequest request, long bidId, long bidderId)
    {
        return new Bid
        {
            BidId = bidId,
            AuctionId = request.AuctionId,
            BidderId = bidderId,
            Amount = request.Amount,
            BidAt = DateTime.UtcNow,
            CreatedAt = DateTime.UtcNow,
            SyncedFromRedis = false,
            BidderIdHash = ComputeSha256(bidderId.ToString())
        };
    }

    private static string ComputeSha256(string input)
    {
        using var sha256 = SHA256.Create();
        var bytes = Encoding.UTF8.GetBytes(input);
        var hash = sha256.ComputeHash(bytes);
        return BitConverter.ToString(hash).Replace("-", "").ToLower();
    }
}
```

## Key Architectural Decisions

### 1. Redis Write-Behind Cache Architecture
- **決策**: Redis 作為主要寫入層，背景 Worker 批次同步至 PostgreSQL
- **原因**: 達成 < 10ms 寫入延遲；減少資料庫寫入壓力；提供高可用性
- **實作**: Redis Lua Script + IHostedService 背景同步

### 2. Lua Script Atomic Operations
- **決策**: 使用 Redis Lua Script 確保併發安全
- **原因**: 原子性操作避免競態條件；單次網路往返；避免樂觀鎖重試開銷
- **實作**: `place-bid.lua` 執行 ZADD + HMSET + SADD

### 3. Snowflake ID Generation
- **決策**: 使用 IdGen/Snowflake.Core 生成 64-bit Long ID
- **原因**: 分散式友善；時間排序性；8 bytes 空間效率
- **實作**: Worker ID=1, Datacenter ID=1, Epoch=2024-01-01

### 4. Field-Level Encryption (AES-256-GCM)
- **決策**: 使用 EF Core Value Converter 加密 Amount 和 BidderId
- **原因**: 保護敏感資料；透明加解密；符合資料隱私法規
- **實作**: EncryptionService + Azure Key Vault

### 5. BidderIdHash for Indexed Queries
- **決策**: 額外儲存 SHA-256 Hash 用於索引查詢
- **原因**: 加密欄位無法建立索引；支援高效能「我的出價記錄」查詢
- **實作**: 計算 SHA-256(BidderId) 並建立複合索引

### 6. Passive Status from Auction Service
- **決策**: 不儲存商品狀態，透過 Auction Service API 查詢
- **原因**: 避免資料重複與不一致；降低服務間耦合
- **實作**: HttpClient + Polly 重試策略

### 7. Background Worker with Exponential Backoff
- **決策**: IHostedService 執行批次同步，失敗時指數退避重試
- **原因**: 提高系統可靠性；避免暫時性錯誤導致資料遺失
- **實作**: 1s → 2s → 4s 重試間隔，3 次失敗後移入死信佇列

## Performance Targets

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| 出價 API 寫入延遲 | <10ms (p95) | Redis 原子操作 |
| 最高出價查詢 | <5ms (p95) | Redis Hash 快取 |
| 出價歷史查詢 (前 20 筆) | <20ms (p95) | Redis Sorted Set |
| 出價歷史查詢 (分頁) | <100ms (p95) | PostgreSQL 索引查詢 |
| 使用者出價記錄查詢 | <200ms (p95) | PostgreSQL BidderIdHash 索引 |
| 支援並發出價數 | 1000 次/秒 (單商品) | Redis Lua Script 併發測試 |
| Redis 快取命中率 | >90% | Prometheus 監控 |
| PostgreSQL 連線池 | 最小 10, 最大 50 | Npgsql Configuration |
| Redis 連線池 | 最小 10, 最大 100 | StackExchange.Redis Configuration |
| 背景同步批次大小 | 1000 筆/秒 | RedisSyncWorker 效能測試 |

## Testing Requirements

### Unit Tests (單元測試)
- **目標覆蓋率**: >80% (業務邏輯)
- **工具**: xUnit + Moq + FluentAssertions
- **範圍**: BidService, RedisCacheService, EncryptionService, Validators
- **Mock**: IBidRepository, IConnectionMultiplexer, IEncryptionService

### Integration Tests (整合測試)
- **工具**: xUnit + Testcontainers (PostgreSQL + Redis)
- **範圍**: BidsController, BidRepository, RedisSyncWorker
- **真實依賴**: PostgreSQL 容器 + Redis 容器

### Load Tests (負載測試)
- **工具**: NBomber 或 K6
- **範圍**: 出價 API 併發測試
- **目標**: 1000 次/秒單商品出價，延遲 < 10ms (p95)

### Contract Tests (契約測試)
- **工具**: xUnit + WireMock.Net
- **範圍**: AuctionServiceClient
- **驗證**: Auction Service API 契約符合性

## Related Documentation

- **Feature Spec**: [spec.md](./spec.md)
- **Implementation Plan**: [plan.md](./plan.md)
- **Research Report**: [research.md](./research.md)
- **Data Model**: [data-model.md](./data-model.md)
- **API Contract**: [contracts/openapi.yaml](./contracts/openapi.yaml)
- **Quickstart Guide**: [quickstart.md](./quickstart.md)

## Constitution Compliance

### ✅ I. Code Quality First
- Repository Pattern + Service Layer 分離
- SOLID 原則（依賴注入、介面導向）
- POCO DTO 手動映射
- Lua Script 封裝複雜邏輯

### ✅ II. Test-Driven Development
- xUnit + Testcontainers 測試策略
- 目標覆蓋率 >80%
- TDD 開發流程（紅燈-綠燈-重構）
- 負載測試驗證效能目標

### ✅ III. User Experience Consistency
- 標準 API 回應格式
- 明確的錯誤代碼與訊息
- Correlation ID 追蹤
- OpenAPI 規格文件

### ✅ IV. Performance Requirements
- 出價寫入 <10ms (p95)
- Redis Write-Behind Cache 架構
- Lua Script 原子操作
- 索引優化查詢效能

### ✅ V. Observability and Monitoring
- Serilog 結構化日誌
- Correlation ID 全鏈路追蹤
- Prometheus 指標監控
- 健康檢查端點

## Configuration

### appsettings.Development.json

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=bidding_dev;Username=bidding_user;Password=bidding_pass",
    "Redis": "localhost:6379,abortConnect=false,connectTimeout=10000"
  },
  "IdGenerator": {
    "WorkerId": 1,
    "DatacenterId": 1,
    "Epoch": "2024-01-01T00:00:00Z"
  },
  "Encryption": {
    "KeyVaultUrl": "https://your-keyvault.vault.azure.net/",
    "KeyName": "bidding-encryption-key",
    "UseLocalKey": true,
    "LocalKey": "DEVELOPMENT_KEY_32_BYTES_BASE64=="
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning",
      "BiddingService": "Debug"
    }
  },
  "Serilog": {
    "MinimumLevel": {
      "Default": "Debug",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {CorrelationId} {Message:lj}{NewLine}{Exception}"
        }
      }
    ]
  },
  "AuctionService": {
    "BaseUrl": "http://localhost:5000",
    "Timeout": 5000
  },
  "BackgroundWorker": {
    "SyncIntervalSeconds": 1,
    "BatchSize": 1000,
    "MaxRetries": 3,
    "RetryDelays": [1000, 2000, 4000]
  }
}
```

## Recent Changes

### 2025-12-04: Phase 0-1 Complete
- ✅ 完成技術研究與選型 (research.md) - 7 個技術決策
- ✅ 完成資料模型設計 (data-model.md) - Bid 實體 + Redis 資料結構
- ✅ 完成 API 契約定義 (openapi.yaml) - 5 個核心端點
- ✅ 完成快速開始指南 (quickstart.md)
- ✅ 建立 feature-specific AI context (.copilot-context.md)
- ✅ 升級技術棧至 .NET 10 / ASP.NET Core 10

## Implementation Status

- ✅ **Phase 0**: Research & Technology Selection
- ✅ **Phase 1**: Design & Contracts
- ⏳ **Phase 2**: Implementation Tasks (待生成 tasks.md)
- ⏳ **Phase 3**: Implementation (TDD)
- ⏳ **Phase 4**: Testing & Deployment

## Merge Conflict Prevention

### Key Differences from Other Features

| Aspect | 001-member-service | 002-auction-service | 003-bidding-service |
|--------|-------------------|--------------------|--------------------|
| **資料庫** | PostgreSQL (會員資料) | PostgreSQL (商品資料) | **PostgreSQL + Redis** |
| **架構** | 標準 CRUD | Repository Pattern | **Write-Behind Cache** |
| **ID 生成** | GUID | GUID | **Snowflake ID (Long)** |
| **加密** | 無 | 無 | **欄位層級加密 (AES-256-GCM)** |
| **背景任務** | 無 | 無 | **IHostedService (Redis Sync)** |
| **快取** | 無 | 無 | **Redis (主要寫入層)** |

### Shared Components (需注意合併衝突)

- ❌ **無共用 Entity** (各服務獨立資料庫)
- ✅ **共用 .github/copilot-instructions.md** (合併時需保留所有服務的技術棧)
- ✅ **共用 docker-compose.yml** (需新增 Redis 服務)
- ✅ **共用 AGENTS.md** (記錄 AI 代理策略)

### Merge Strategy Recommendations

1. **先合併 master 至 003-bidding-service**:
   ```powershell
   git checkout 003-bidding-service
   git merge master
   ```

2. **解決 .github/copilot-instructions.md 衝突**:
   - 保留所有服務的 `Active Technologies` 條目
   - 不刪除其他分支新增的內容

3. **解決 docker-compose.yml 衝突**:
   - 新增 `redis_bidding` 服務
   - 保留其他服務的容器定義

4. **測試獨立性**:
   - 確保各服務可獨立執行

---

<!-- MANUAL ADDITIONS START -->
<!-- 手動新增的內容請放在此區塊，合併時不會被覆蓋 -->

<!-- MANUAL ADDITIONS END -->
