# AuctionService Development Context (002-auction-service)

**Feature-Specific AI Context** | **Branch**: 002-auction-service | **Last Updated**: 2025-12-02

## Feature Overview

商品拍賣服務後端 REST API，提供商品的建立、查詢、管理與使用者追蹤功能。採用 ASP.NET Core 10 Web API 搭配 PostgreSQL 資料庫，使用 Entity Framework Core Code First 工作流程。

**核心特性**:
- 商品瀏覽與搜尋（分頁、篩選、排序）
- 商品建立與管理（CRUD 操作）
- 商品追蹤功能（使用者收藏）
- 被動式狀態管理（透過 StartTime/EndTime 即時計算）
- 與 Bidding Service 整合（查詢當前競標價格）
- 標準化 API 回應格式（ResponseCode 管理）

## Active Technologies

### Core Stack
- **Language**: C# 13 / .NET 10 LTS
- **Framework**: ASP.NET Core 10 Web API (Controller-based, **不使用 Minimal APIs**)
- **Database**: PostgreSQL 16+
- **ORM**: Entity Framework Core 10 (Code First workflow)
- **API Gateway**: YARP (Yet Another Reverse Proxy)

### Key Dependencies
- **Npgsql.EntityFrameworkCore.PostgreSQL** 10.0+ - PostgreSQL 驅動
- **FluentValidation.AspNetCore** 11.3.0 - 輸入驗證
- **Serilog.AspNetCore** 8.0 - 結構化日誌
- **Polly** 8.0+ - HTTP 重試策略（整合 Bidding Service）
- **Swashbuckle.AspNetCore** 6.5+ - OpenAPI 文件生成

### Testing Stack
- **xUnit** 2.6+ - 測試框架
- **Moq** 4.20+ - Mock 框架
- **FluentAssertions** 6.12+ - 斷言庫
- **Testcontainers.PostgreSql** 3.7+ - 整合測試容器

### Architecture Pattern
- **Clean Architecture**: 分層結構（Core / Infrastructure / Api / Shared）
- **Repository Pattern**: 資料存取抽象
- **POCO DTOs**: 手動映射，**不使用 AutoMapper**

## Project Structure

```text
AuctionService/                      # 單一專案根目錄
├── AuctionService.sln               # Visual Studio 解決方案
├── README.md                        # 專案說明文件
├── docker-compose.yml               # 本地開發環境
├── Dockerfile                       # API 容器映像
│
├── src/
│   ├── AuctionService.Api/          # API 層 (Controllers, Middleware)
│   ├── AuctionService.Core/         # 核心業務邏輯 (Entities, DTOs, Services, Interfaces)
│   ├── AuctionService.Infrastructure/ # 基礎設施層 (DbContext, Repositories, HttpClients)
│   └── AuctionService.Shared/       # 共用工具 (Constants, Extensions, Helpers)
│
└── tests/
    ├── AuctionService.UnitTests/    # 單元測試
    ├── AuctionService.IntegrationTests/ # 整合測試 (Testcontainers)
    └── AuctionService.ContractTests/ # 契約測試
```

## Commands

### Development

```powershell
# 啟動開發環境
cd AuctionService
dotnet restore
dotnet build

# 執行 API
cd src/AuctionService.Api
dotnet run

# 執行 PostgreSQL (Docker)
docker run -d --name auction-db `
  -e POSTGRES_USER=auction `
  -e POSTGRES_PASSWORD=Dev@Password123 `
  -e POSTGRES_DB=auctiondb `
  -p 5432:5432 postgres:16-alpine

# EF Core Migrations
dotnet ef migrations add InitialCreate --project src/AuctionService.Infrastructure --startup-project src/AuctionService.Api
dotnet ef database update --project src/AuctionService.Infrastructure --startup-project src/AuctionService.Api
```

### Testing

```powershell
# 執行所有測試
dotnet test

# 執行單元測試
dotnet test tests/AuctionService.UnitTests

# 執行整合測試 (使用 Testcontainers)
dotnet test tests/AuctionService.IntegrationTests

# 測試覆蓋率報告
dotnet test /p:CollectCoverage=true /p:CoverletOutputFormat=opencover
```

### Database

```sql
-- 查詢所有拍賣商品
SELECT "Id", "Name", "StartingPrice", "CategoryId", "StartTime", "EndTime", "UserId", "CreatedAt"
FROM "Auctions"
WHERE "EndTime" > NOW()
ORDER BY "CreatedAt" DESC;

-- 查詢特定使用者的追蹤清單
SELECT a."Id", a."Name", f."CreatedAt" AS "FollowedAt"
FROM "Follows" f
JOIN "Auctions" a ON f."AuctionId" = a."Id"
WHERE f."UserId" = '00000000-0000-0000-0000-000000000001'
ORDER BY f."CreatedAt" DESC;

-- 查詢回應代碼
SELECT "Code", "Name", "MessageZhTw", "MessageEn", "Category", "Severity"
FROM "ResponseCodes"
WHERE "Category" = 'Auction';
```

## Code Style

### Controller Pattern (Controller-based, 不使用 Minimal APIs)

```csharp
[ApiController]
[Route("api/[controller]")]
public class AuctionsController : ControllerBase
{
    private readonly IAuctionService _auctionService;
    private readonly ILogger<AuctionsController> _logger;

    public AuctionsController(IAuctionService auctionService, ILogger<AuctionsController> logger)
    {
        _auctionService = auctionService;
        _logger = logger;
    }

    [HttpGet]
    [ProducesResponseType(typeof(ApiResponse<PagedResult<AuctionListItemDto>>), StatusCodes.Status200OK)]
    public async Task<IActionResult> GetAuctions([FromQuery] AuctionQueryParameters parameters)
    {
        var result = await _auctionService.GetAuctionsAsync(parameters);
        return Ok(new ApiResponse<PagedResult<AuctionListItemDto>>
        {
            Success = true,
            Data = result,
            Metadata = new ResponseMetadata
            {
                StatusCode = "SUCCESS",
                StatusName = "查詢成功",
                Message = "成功取得拍賣商品清單",
                Timestamp = DateTime.UtcNow,
                Path = HttpContext.Request.Path
            }
        });
    }
}
```

### POCO DTO Mapping (手動映射，不使用 AutoMapper)

```csharp
// Entity to DTO
public static AuctionDetailDto ToDetailDto(this Auction auction, decimal? currentBid = null)
{
    return new AuctionDetailDto
    {
        Id = auction.Id,
        Name = auction.Name,
        Description = auction.Description,
        StartingPrice = auction.StartingPrice,
        CurrentBid = currentBid,
        CategoryId = auction.CategoryId,
        CategoryName = auction.Category?.Name,
        Status = auction.CalculateStatus(), // 被動式狀態計算
        StartTime = auction.StartTime,
        EndTime = auction.EndTime,
        UserId = auction.UserId,
        CreatedAt = auction.CreatedAt,
        UpdatedAt = auction.UpdatedAt
    };
}

// DTO to Entity
public static Auction ToEntity(this CreateAuctionRequest request)
{
    return new Auction
    {
        Id = Guid.NewGuid(),
        Name = request.Name,
        Description = request.Description,
        StartingPrice = request.StartingPrice,
        CategoryId = request.CategoryId,
        StartTime = request.StartTime,
        EndTime = request.EndTime,
        UserId = request.UserId,
        CreatedAt = DateTime.UtcNow,
        UpdatedAt = DateTime.UtcNow
    };
}
```

### Entity Framework Core (Code First with Fluent API)

```csharp
public class AuctionConfiguration : IEntityTypeConfiguration<Auction>
{
    public void Configure(EntityTypeBuilder<Auction> builder)
    {
        builder.ToTable("Auctions");
        
        builder.HasKey(a => a.Id);
        
        builder.Property(a => a.Name)
            .IsRequired()
            .HasMaxLength(200);
        
        builder.Property(a => a.Description)
            .HasMaxLength(2000);
        
        builder.Property(a => a.StartingPrice)
            .HasPrecision(18, 2)
            .IsRequired();
        
        // 索引優化：EndTime 用於狀態篩選
        builder.HasIndex(a => a.EndTime)
            .HasDatabaseName("IX_Auctions_EndTime");
        
        // 複合索引：使用者查詢優化
        builder.HasIndex(a => new { a.UserId, a.CreatedAt })
            .HasDatabaseName("IX_Auctions_UserId_CreatedAt");
        
        // 外鍵關聯
        builder.HasOne(a => a.Category)
            .WithMany()
            .HasForeignKey(a => a.CategoryId)
            .OnDelete(DeleteBehavior.Restrict);
    }
}
```

### Passive Status Calculation (被動式狀態管理)

```csharp
public static class AuctionExtensions
{
    public static AuctionStatus CalculateStatus(this Auction auction)
    {
        var now = DateTime.UtcNow;
        
        if (now < auction.StartTime)
            return AuctionStatus.NotStarted;
        
        if (now >= auction.StartTime && now < auction.EndTime)
            return AuctionStatus.Active;
        
        return AuctionStatus.Ended;
    }
}
```

### HttpClient + Polly Integration (Bidding Service)

```csharp
public class BiddingServiceClient : IBiddingServiceClient
{
    private readonly HttpClient _httpClient;
    private readonly ILogger<BiddingServiceClient> _logger;

    public BiddingServiceClient(HttpClient httpClient, ILogger<BiddingServiceClient> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
    }

    public async Task<decimal?> GetCurrentBidAsync(Guid auctionId)
    {
        try
        {
            _logger.LogInformation("Calling Bidding Service for auction {AuctionId}", auctionId);
            
            var response = await _httpClient.GetAsync($"/api/bids/auction/{auctionId}/current");
            
            if (!response.IsSuccessStatusCode)
            {
                _logger.LogWarning("Bidding Service returned {StatusCode} for auction {AuctionId}", 
                    response.StatusCode, auctionId);
                return null;
            }
            
            var result = await response.Content.ReadFromJsonAsync<CurrentBidResponse>();
            return result?.CurrentBid;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get current bid for auction {AuctionId}", auctionId);
            return null;
        }
    }
}

// Startup.cs or Program.cs
builder.Services.AddHttpClient<IBiddingServiceClient, BiddingServiceClient>(client =>
{
    client.BaseAddress = new Uri(builder.Configuration["Services:BiddingService"]);
    client.Timeout = TimeSpan.FromSeconds(5);
})
.AddTransientHttpErrorPolicy(policy => 
    policy.WaitAndRetryAsync(3, retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt))))
.AddTransientHttpErrorPolicy(policy => 
    policy.CircuitBreakerAsync(5, TimeSpan.FromSeconds(30)));
```

## Key Architectural Decisions

### 1. Passive Status Management (被動式狀態管理)
- **決策**: 商品狀態不儲存在資料庫，而是在查詢時透過 `StartTime` 和 `EndTime` 即時計算
- **原因**: 避免背景任務開銷；減少資料不一致風險；簡化資料模型
- **實作**: 使用 Extension Methods (`CalculateStatus()`) 在 DTO 映射時計算狀態

### 2. POCO Manual DTO Mapping (手動 DTO 映射)
- **決策**: 使用 POCO 手動映射，不使用 AutoMapper
- **原因**: 提升效能（避免反射開銷）；增強可讀性（明確的映射邏輯）；更好的編譯時期檢查
- **實作**: 使用 Extension Methods 提供 `ToDto()` 和 `ToEntity()` 方法

### 3. Repository Pattern with Generic Base (泛型 Repository 基底)
- **決策**: 使用泛型 Repository 基底 + 特化 Repository
- **原因**: 減少重複程式碼；提供統一的資料存取介面；便於單元測試 Mock
- **實作**: `IRepository<T>` + `IAuctionRepository` (特化查詢)

### 4. ResponseCode Table for API Standardization (API 回應標準化)
- **決策**: 使用 `ResponseCodes` 資料表管理所有 API 狀態代碼與多語系訊息
- **原因**: 統一回應格式；支援多語系（繁體中文/英文）；集中管理錯誤代碼
- **實作**: Seed 資料 + ResponseCodeService 查詢

### 5. Clean Architecture Layering (清潔架構分層)
- **決策**: 採用 Clean Architecture 分層（Core → Infrastructure → Api）
- **原因**: 清晰的依賴方向；高度可測試性；易於維護與擴展
- **實作**: 
  - `Core`: Entities, DTOs, Interfaces, Services (無外部依賴)
  - `Infrastructure`: DbContext, Repositories, HttpClients (實作 Core 介面)
  - `Api`: Controllers, Middleware, Filters (依賴 Core 介面)
  - `Shared`: Constants, Extensions, Helpers (跨層共用)

## Performance Targets

| Metric | Target | Measurement Method |
|--------|--------|-------------------|
| 商品清單查詢 | <200ms (p95) | Application Insights / Prometheus |
| 商品詳細資訊查詢 | <300ms (p95) | Application Insights / Prometheus |
| 商品建立/更新 | <500ms (p95) | Application Insights / Prometheus |
| 追蹤清單查詢 | <200ms (p95) | Application Insights / Prometheus |
| 支援並發請求數 | 100+ req/s | Load Testing (Apache JMeter / k6) |
| 資料庫連線池 | 最小 10, 最大 100 | Npgsql Configuration |
| 記憶體使用 | <512MB (容器) | Docker Stats / Prometheus |

## Testing Requirements

### Unit Tests (單元測試)
- **目標覆蓋率**: >80% (業務邏輯)
- **工具**: xUnit + Moq + FluentAssertions
- **範圍**: Services, Validators, Extensions, Helpers
- **Mock**: Repositories, HttpClients, DbContext

### Integration Tests (整合測試)
- **工具**: xUnit + Testcontainers.PostgreSql
- **範圍**: Controllers, Repositories, DbContext
- **真實依賴**: PostgreSQL (Testcontainers 容器)

### Contract Tests (契約測試)
- **工具**: xUnit + WireMock.Net
- **範圍**: BiddingServiceClient
- **驗證**: OpenAPI 契約符合性

## Related Documentation

- **Feature Spec**: [spec.md](./spec.md)
- **Implementation Plan**: [plan.md](./plan.md)
- **Research Report**: [research.md](./research.md)
- **Data Model**: [data-model.md](./data-model.md)
- **API Contract**: [contracts/openapi.yaml](./contracts/openapi.yaml)
- **Quickstart Guide**: [quickstart.md](./quickstart.md)

## Constitution Compliance

### ✅ I. Code Quality First
- Clean Architecture 分層架構
- SOLID 原則（依賴注入、介面導向）
- Repository Pattern 資料存取抽象
- POCO DTO 手動映射

### ✅ II. Test-Driven Development
- xUnit + Testcontainers 測試策略
- 目標覆蓋率 >80%
- TDD 開發流程（紅燈-綠燈-重構）

### ✅ III. User Experience Consistency
- ResponseCode 資料表統一管理
- 標準 API 回應格式
- 多語系支援（繁體中文/英文）
- 明確的驗證錯誤訊息

### ✅ IV. Performance Requirements
- 商品清單查詢 <200ms (p95)
- 商品詳細資訊 <300ms (p95)
- EndTime 索引優化狀態篩選
- 分頁限制每頁 20 筆

### ✅ V. Observability and Monitoring
- Serilog 結構化日誌
- Correlation ID 追蹤
- 記錄所有 Bidding Service 呼叫
- 健康檢查端點

## Configuration

### appsettings.Development.json

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Port=5432;Database=auctiondb;Username=auction;Password=Dev@Password123"
  },
  "Services": {
    "BiddingService": "http://localhost:5002"
  },
  "Serilog": {
    "MinimumLevel": {
      "Default": "Debug",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console",
        "Args": {
          "outputTemplate": "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} {Properties:j}{NewLine}{Exception}"
        }
      }
    ]
  },
  "Pagination": {
    "MaxPageSize": 50,
    "DefaultPageSize": 20
  }
}
```

## Recent Changes

### 2025-12-02: Phase 0-1 Complete
- ✅ 完成技術研究與選型 (research.md)
- ✅ 完成資料模型設計 (data-model.md) - 4 個實體
- ✅ 完成 API 契約定義 (openapi.yaml) - 11 個端點
- ✅ 完成快速開始指南 (quickstart.md)
- ✅ 建立 feature-specific AI context (.copilot-context.md)

## Implementation Status

- ✅ **Phase 0**: Research & Technology Selection
- ✅ **Phase 1**: Design & Contracts
- ⏳ **Phase 2**: Implementation Tasks (待生成 tasks.md)
- ⏳ **Phase 3**: Implementation (TDD)
- ⏳ **Phase 4**: Testing & Deployment

---

<!-- MANUAL ADDITIONS START -->
<!-- 手動新增的內容請放在此區塊，合併時不會被覆蓋 -->

<!-- MANUAL ADDITIONS END -->
